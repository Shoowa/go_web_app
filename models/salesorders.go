// Code generated by SQLBoiler 4.13.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Salesorder is an object representing the database table.
type Salesorder struct {
	ID           int       `boil:"id" json:"id" toml:"id" yaml:"id"`
	CommissionID int       `boil:"commission_id" json:"commission_id" toml:"commission_id" yaml:"commission_id"`
	BuyerID      int       `boil:"buyer_id" json:"buyer_id" toml:"buyer_id" yaml:"buyer_id"`
	SellerID     int       `boil:"seller_id" json:"seller_id" toml:"seller_id" yaml:"seller_id"`
	Created      time.Time `boil:"created" json:"created" toml:"created" yaml:"created"`
	AgentID      null.Int  `boil:"agent_id" json:"agent_id,omitempty" toml:"agent_id" yaml:"agent_id,omitempty"`
	ExpectedMin  time.Time `boil:"expected_min" json:"expected_min" toml:"expected_min" yaml:"expected_min"`
	ExpectedMax  time.Time `boil:"expected_max" json:"expected_max" toml:"expected_max" yaml:"expected_max"`
	AccountID    null.Int  `boil:"account_id" json:"account_id,omitempty" toml:"account_id" yaml:"account_id,omitempty"`
	Cancel       null.Bool `boil:"cancel" json:"cancel,omitempty" toml:"cancel" yaml:"cancel,omitempty"`

	R *salesorderR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L salesorderL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var SalesorderColumns = struct {
	ID           string
	CommissionID string
	BuyerID      string
	SellerID     string
	Created      string
	AgentID      string
	ExpectedMin  string
	ExpectedMax  string
	AccountID    string
	Cancel       string
}{
	ID:           "id",
	CommissionID: "commission_id",
	BuyerID:      "buyer_id",
	SellerID:     "seller_id",
	Created:      "created",
	AgentID:      "agent_id",
	ExpectedMin:  "expected_min",
	ExpectedMax:  "expected_max",
	AccountID:    "account_id",
	Cancel:       "cancel",
}

var SalesorderTableColumns = struct {
	ID           string
	CommissionID string
	BuyerID      string
	SellerID     string
	Created      string
	AgentID      string
	ExpectedMin  string
	ExpectedMax  string
	AccountID    string
	Cancel       string
}{
	ID:           "salesorders.id",
	CommissionID: "salesorders.commission_id",
	BuyerID:      "salesorders.buyer_id",
	SellerID:     "salesorders.seller_id",
	Created:      "salesorders.created",
	AgentID:      "salesorders.agent_id",
	ExpectedMin:  "salesorders.expected_min",
	ExpectedMax:  "salesorders.expected_max",
	AccountID:    "salesorders.account_id",
	Cancel:       "salesorders.cancel",
}

// Generated where

var SalesorderWhere = struct {
	ID           whereHelperint
	CommissionID whereHelperint
	BuyerID      whereHelperint
	SellerID     whereHelperint
	Created      whereHelpertime_Time
	AgentID      whereHelpernull_Int
	ExpectedMin  whereHelpertime_Time
	ExpectedMax  whereHelpertime_Time
	AccountID    whereHelpernull_Int
	Cancel       whereHelpernull_Bool
}{
	ID:           whereHelperint{field: "\"alpha\".\"salesorders\".\"id\""},
	CommissionID: whereHelperint{field: "\"alpha\".\"salesorders\".\"commission_id\""},
	BuyerID:      whereHelperint{field: "\"alpha\".\"salesorders\".\"buyer_id\""},
	SellerID:     whereHelperint{field: "\"alpha\".\"salesorders\".\"seller_id\""},
	Created:      whereHelpertime_Time{field: "\"alpha\".\"salesorders\".\"created\""},
	AgentID:      whereHelpernull_Int{field: "\"alpha\".\"salesorders\".\"agent_id\""},
	ExpectedMin:  whereHelpertime_Time{field: "\"alpha\".\"salesorders\".\"expected_min\""},
	ExpectedMax:  whereHelpertime_Time{field: "\"alpha\".\"salesorders\".\"expected_max\""},
	AccountID:    whereHelpernull_Int{field: "\"alpha\".\"salesorders\".\"account_id\""},
	Cancel:       whereHelpernull_Bool{field: "\"alpha\".\"salesorders\".\"cancel\""},
}

// SalesorderRels is where relationship names are stored.
var SalesorderRels = struct {
	Account                string
	Agent                  string
	Buyer                  string
	Commission             string
	Seller                 string
	SalesorderCancellation string
	Deliveries             string
	DeliveryComplaints     string
	Receipts               string
	Refunds                string
	SalesorderItems        string
	TaxExemptions          string
}{
	Account:                "Account",
	Agent:                  "Agent",
	Buyer:                  "Buyer",
	Commission:             "Commission",
	Seller:                 "Seller",
	SalesorderCancellation: "SalesorderCancellation",
	Deliveries:             "Deliveries",
	DeliveryComplaints:     "DeliveryComplaints",
	Receipts:               "Receipts",
	Refunds:                "Refunds",
	SalesorderItems:        "SalesorderItems",
	TaxExemptions:          "TaxExemptions",
}

// salesorderR is where relationships are stored.
type salesorderR struct {
	Account                *Payment                `boil:"Account" json:"Account" toml:"Account" yaml:"Account"`
	Agent                  *Person                 `boil:"Agent" json:"Agent" toml:"Agent" yaml:"Agent"`
	Buyer                  *Company                `boil:"Buyer" json:"Buyer" toml:"Buyer" yaml:"Buyer"`
	Commission             *Commission             `boil:"Commission" json:"Commission" toml:"Commission" yaml:"Commission"`
	Seller                 *Company                `boil:"Seller" json:"Seller" toml:"Seller" yaml:"Seller"`
	SalesorderCancellation *SalesorderCancellation `boil:"SalesorderCancellation" json:"SalesorderCancellation" toml:"SalesorderCancellation" yaml:"SalesorderCancellation"`
	Deliveries             DeliverySlice           `boil:"Deliveries" json:"Deliveries" toml:"Deliveries" yaml:"Deliveries"`
	DeliveryComplaints     DeliveryComplaintSlice  `boil:"DeliveryComplaints" json:"DeliveryComplaints" toml:"DeliveryComplaints" yaml:"DeliveryComplaints"`
	Receipts               ReceiptSlice            `boil:"Receipts" json:"Receipts" toml:"Receipts" yaml:"Receipts"`
	Refunds                RefundSlice             `boil:"Refunds" json:"Refunds" toml:"Refunds" yaml:"Refunds"`
	SalesorderItems        SalesorderItemSlice     `boil:"SalesorderItems" json:"SalesorderItems" toml:"SalesorderItems" yaml:"SalesorderItems"`
	TaxExemptions          TaxExemptionSlice       `boil:"TaxExemptions" json:"TaxExemptions" toml:"TaxExemptions" yaml:"TaxExemptions"`
}

// NewStruct creates a new relationship struct
func (*salesorderR) NewStruct() *salesorderR {
	return &salesorderR{}
}

func (r *salesorderR) GetAccount() *Payment {
	if r == nil {
		return nil
	}
	return r.Account
}

func (r *salesorderR) GetAgent() *Person {
	if r == nil {
		return nil
	}
	return r.Agent
}

func (r *salesorderR) GetBuyer() *Company {
	if r == nil {
		return nil
	}
	return r.Buyer
}

func (r *salesorderR) GetCommission() *Commission {
	if r == nil {
		return nil
	}
	return r.Commission
}

func (r *salesorderR) GetSeller() *Company {
	if r == nil {
		return nil
	}
	return r.Seller
}

func (r *salesorderR) GetSalesorderCancellation() *SalesorderCancellation {
	if r == nil {
		return nil
	}
	return r.SalesorderCancellation
}

func (r *salesorderR) GetDeliveries() DeliverySlice {
	if r == nil {
		return nil
	}
	return r.Deliveries
}

func (r *salesorderR) GetDeliveryComplaints() DeliveryComplaintSlice {
	if r == nil {
		return nil
	}
	return r.DeliveryComplaints
}

func (r *salesorderR) GetReceipts() ReceiptSlice {
	if r == nil {
		return nil
	}
	return r.Receipts
}

func (r *salesorderR) GetRefunds() RefundSlice {
	if r == nil {
		return nil
	}
	return r.Refunds
}

func (r *salesorderR) GetSalesorderItems() SalesorderItemSlice {
	if r == nil {
		return nil
	}
	return r.SalesorderItems
}

func (r *salesorderR) GetTaxExemptions() TaxExemptionSlice {
	if r == nil {
		return nil
	}
	return r.TaxExemptions
}

// salesorderL is where Load methods for each relationship are stored.
type salesorderL struct{}

var (
	salesorderAllColumns            = []string{"id", "commission_id", "buyer_id", "seller_id", "created", "agent_id", "expected_min", "expected_max", "account_id", "cancel"}
	salesorderColumnsWithoutDefault = []string{"commission_id", "buyer_id", "seller_id", "expected_min", "expected_max"}
	salesorderColumnsWithDefault    = []string{"id", "created", "agent_id", "account_id", "cancel"}
	salesorderPrimaryKeyColumns     = []string{"id"}
	salesorderGeneratedColumns      = []string{"id"}
)

type (
	// SalesorderSlice is an alias for a slice of pointers to Salesorder.
	// This should almost always be used instead of []Salesorder.
	SalesorderSlice []*Salesorder

	salesorderQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	salesorderType                 = reflect.TypeOf(&Salesorder{})
	salesorderMapping              = queries.MakeStructMapping(salesorderType)
	salesorderPrimaryKeyMapping, _ = queries.BindMapping(salesorderType, salesorderMapping, salesorderPrimaryKeyColumns)
	salesorderInsertCacheMut       sync.RWMutex
	salesorderInsertCache          = make(map[string]insertCache)
	salesorderUpdateCacheMut       sync.RWMutex
	salesorderUpdateCache          = make(map[string]updateCache)
	salesorderUpsertCacheMut       sync.RWMutex
	salesorderUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// OneG returns a single salesorder record from the query using the global executor.
func (q salesorderQuery) OneG(ctx context.Context) (*Salesorder, error) {
	return q.One(ctx, boil.GetContextDB())
}

// One returns a single salesorder record from the query.
func (q salesorderQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Salesorder, error) {
	o := &Salesorder{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for salesorders")
	}

	return o, nil
}

// AllG returns all Salesorder records from the query using the global executor.
func (q salesorderQuery) AllG(ctx context.Context) (SalesorderSlice, error) {
	return q.All(ctx, boil.GetContextDB())
}

// All returns all Salesorder records from the query.
func (q salesorderQuery) All(ctx context.Context, exec boil.ContextExecutor) (SalesorderSlice, error) {
	var o []*Salesorder

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Salesorder slice")
	}

	return o, nil
}

// CountG returns the count of all Salesorder records in the query using the global executor
func (q salesorderQuery) CountG(ctx context.Context) (int64, error) {
	return q.Count(ctx, boil.GetContextDB())
}

// Count returns the count of all Salesorder records in the query.
func (q salesorderQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count salesorders rows")
	}

	return count, nil
}

// ExistsG checks if the row exists in the table using the global executor.
func (q salesorderQuery) ExistsG(ctx context.Context) (bool, error) {
	return q.Exists(ctx, boil.GetContextDB())
}

// Exists checks if the row exists in the table.
func (q salesorderQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if salesorders exists")
	}

	return count > 0, nil
}

// Account pointed to by the foreign key.
func (o *Salesorder) Account(mods ...qm.QueryMod) paymentQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.AccountID),
	}

	queryMods = append(queryMods, mods...)

	return Payments(queryMods...)
}

// Agent pointed to by the foreign key.
func (o *Salesorder) Agent(mods ...qm.QueryMod) personQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.AgentID),
	}

	queryMods = append(queryMods, mods...)

	return Persons(queryMods...)
}

// Buyer pointed to by the foreign key.
func (o *Salesorder) Buyer(mods ...qm.QueryMod) companyQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.BuyerID),
	}

	queryMods = append(queryMods, mods...)

	return Companies(queryMods...)
}

// Commission pointed to by the foreign key.
func (o *Salesorder) Commission(mods ...qm.QueryMod) commissionQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.CommissionID),
	}

	queryMods = append(queryMods, mods...)

	return Commissions(queryMods...)
}

// Seller pointed to by the foreign key.
func (o *Salesorder) Seller(mods ...qm.QueryMod) companyQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.SellerID),
	}

	queryMods = append(queryMods, mods...)

	return Companies(queryMods...)
}

// SalesorderCancellation pointed to by the foreign key.
func (o *Salesorder) SalesorderCancellation(mods ...qm.QueryMod) salesorderCancellationQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"salesorder_id\" = ?", o.ID),
	}

	queryMods = append(queryMods, mods...)

	return SalesorderCancellations(queryMods...)
}

// Deliveries retrieves all the delivery's Deliveries with an executor.
func (o *Salesorder) Deliveries(mods ...qm.QueryMod) deliveryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"alpha\".\"delivery\".\"salesorder_id\"=?", o.ID),
	)

	return Deliveries(queryMods...)
}

// DeliveryComplaints retrieves all the delivery_complaint's DeliveryComplaints with an executor.
func (o *Salesorder) DeliveryComplaints(mods ...qm.QueryMod) deliveryComplaintQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"alpha\".\"delivery_complaints\".\"salesorder_id\"=?", o.ID),
	)

	return DeliveryComplaints(queryMods...)
}

// Receipts retrieves all the receipt's Receipts with an executor.
func (o *Salesorder) Receipts(mods ...qm.QueryMod) receiptQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"alpha\".\"receipts\".\"salesorder_id\"=?", o.ID),
	)

	return Receipts(queryMods...)
}

// Refunds retrieves all the refund's Refunds with an executor.
func (o *Salesorder) Refunds(mods ...qm.QueryMod) refundQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"alpha\".\"refunds\".\"salesorder_id\"=?", o.ID),
	)

	return Refunds(queryMods...)
}

// SalesorderItems retrieves all the salesorder_item's SalesorderItems with an executor.
func (o *Salesorder) SalesorderItems(mods ...qm.QueryMod) salesorderItemQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"alpha\".\"salesorder_items\".\"salesorder_id\"=?", o.ID),
	)

	return SalesorderItems(queryMods...)
}

// TaxExemptions retrieves all the tax_exemption's TaxExemptions with an executor.
func (o *Salesorder) TaxExemptions(mods ...qm.QueryMod) taxExemptionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"alpha\".\"tax_exemptions\".\"salesorder_id\"=?", o.ID),
	)

	return TaxExemptions(queryMods...)
}

// LoadAccount allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (salesorderL) LoadAccount(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSalesorder interface{}, mods queries.Applicator) error {
	var slice []*Salesorder
	var object *Salesorder

	if singular {
		var ok bool
		object, ok = maybeSalesorder.(*Salesorder)
		if !ok {
			object = new(Salesorder)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeSalesorder)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeSalesorder))
			}
		}
	} else {
		s, ok := maybeSalesorder.(*[]*Salesorder)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeSalesorder)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeSalesorder))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &salesorderR{}
		}
		if !queries.IsNil(object.AccountID) {
			args = append(args, object.AccountID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &salesorderR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.AccountID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.AccountID) {
				args = append(args, obj.AccountID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`alpha.payment`),
		qm.WhereIn(`alpha.payment.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Payment")
	}

	var resultSlice []*Payment
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Payment")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for payment")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for payment")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Account = foreign
		if foreign.R == nil {
			foreign.R = &paymentR{}
		}
		foreign.R.AccountSalesorders = append(foreign.R.AccountSalesorders, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.AccountID, foreign.ID) {
				local.R.Account = foreign
				if foreign.R == nil {
					foreign.R = &paymentR{}
				}
				foreign.R.AccountSalesorders = append(foreign.R.AccountSalesorders, local)
				break
			}
		}
	}

	return nil
}

// LoadAgent allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (salesorderL) LoadAgent(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSalesorder interface{}, mods queries.Applicator) error {
	var slice []*Salesorder
	var object *Salesorder

	if singular {
		var ok bool
		object, ok = maybeSalesorder.(*Salesorder)
		if !ok {
			object = new(Salesorder)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeSalesorder)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeSalesorder))
			}
		}
	} else {
		s, ok := maybeSalesorder.(*[]*Salesorder)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeSalesorder)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeSalesorder))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &salesorderR{}
		}
		if !queries.IsNil(object.AgentID) {
			args = append(args, object.AgentID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &salesorderR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.AgentID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.AgentID) {
				args = append(args, obj.AgentID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`alpha.persons`),
		qm.WhereIn(`alpha.persons.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Person")
	}

	var resultSlice []*Person
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Person")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for persons")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for persons")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Agent = foreign
		if foreign.R == nil {
			foreign.R = &personR{}
		}
		foreign.R.AgentSalesorders = append(foreign.R.AgentSalesorders, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.AgentID, foreign.ID) {
				local.R.Agent = foreign
				if foreign.R == nil {
					foreign.R = &personR{}
				}
				foreign.R.AgentSalesorders = append(foreign.R.AgentSalesorders, local)
				break
			}
		}
	}

	return nil
}

// LoadBuyer allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (salesorderL) LoadBuyer(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSalesorder interface{}, mods queries.Applicator) error {
	var slice []*Salesorder
	var object *Salesorder

	if singular {
		var ok bool
		object, ok = maybeSalesorder.(*Salesorder)
		if !ok {
			object = new(Salesorder)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeSalesorder)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeSalesorder))
			}
		}
	} else {
		s, ok := maybeSalesorder.(*[]*Salesorder)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeSalesorder)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeSalesorder))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &salesorderR{}
		}
		args = append(args, object.BuyerID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &salesorderR{}
			}

			for _, a := range args {
				if a == obj.BuyerID {
					continue Outer
				}
			}

			args = append(args, obj.BuyerID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`alpha.companies`),
		qm.WhereIn(`alpha.companies.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Company")
	}

	var resultSlice []*Company
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Company")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for companies")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for companies")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Buyer = foreign
		if foreign.R == nil {
			foreign.R = &companyR{}
		}
		foreign.R.BuyerSalesorders = append(foreign.R.BuyerSalesorders, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.BuyerID == foreign.ID {
				local.R.Buyer = foreign
				if foreign.R == nil {
					foreign.R = &companyR{}
				}
				foreign.R.BuyerSalesorders = append(foreign.R.BuyerSalesorders, local)
				break
			}
		}
	}

	return nil
}

// LoadCommission allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (salesorderL) LoadCommission(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSalesorder interface{}, mods queries.Applicator) error {
	var slice []*Salesorder
	var object *Salesorder

	if singular {
		var ok bool
		object, ok = maybeSalesorder.(*Salesorder)
		if !ok {
			object = new(Salesorder)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeSalesorder)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeSalesorder))
			}
		}
	} else {
		s, ok := maybeSalesorder.(*[]*Salesorder)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeSalesorder)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeSalesorder))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &salesorderR{}
		}
		args = append(args, object.CommissionID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &salesorderR{}
			}

			for _, a := range args {
				if a == obj.CommissionID {
					continue Outer
				}
			}

			args = append(args, obj.CommissionID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`alpha.commissions`),
		qm.WhereIn(`alpha.commissions.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Commission")
	}

	var resultSlice []*Commission
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Commission")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for commissions")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for commissions")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Commission = foreign
		if foreign.R == nil {
			foreign.R = &commissionR{}
		}
		foreign.R.Salesorders = append(foreign.R.Salesorders, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.CommissionID == foreign.ID {
				local.R.Commission = foreign
				if foreign.R == nil {
					foreign.R = &commissionR{}
				}
				foreign.R.Salesorders = append(foreign.R.Salesorders, local)
				break
			}
		}
	}

	return nil
}

// LoadSeller allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (salesorderL) LoadSeller(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSalesorder interface{}, mods queries.Applicator) error {
	var slice []*Salesorder
	var object *Salesorder

	if singular {
		var ok bool
		object, ok = maybeSalesorder.(*Salesorder)
		if !ok {
			object = new(Salesorder)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeSalesorder)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeSalesorder))
			}
		}
	} else {
		s, ok := maybeSalesorder.(*[]*Salesorder)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeSalesorder)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeSalesorder))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &salesorderR{}
		}
		args = append(args, object.SellerID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &salesorderR{}
			}

			for _, a := range args {
				if a == obj.SellerID {
					continue Outer
				}
			}

			args = append(args, obj.SellerID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`alpha.companies`),
		qm.WhereIn(`alpha.companies.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Company")
	}

	var resultSlice []*Company
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Company")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for companies")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for companies")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Seller = foreign
		if foreign.R == nil {
			foreign.R = &companyR{}
		}
		foreign.R.SellerSalesorders = append(foreign.R.SellerSalesorders, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.SellerID == foreign.ID {
				local.R.Seller = foreign
				if foreign.R == nil {
					foreign.R = &companyR{}
				}
				foreign.R.SellerSalesorders = append(foreign.R.SellerSalesorders, local)
				break
			}
		}
	}

	return nil
}

// LoadSalesorderCancellation allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (salesorderL) LoadSalesorderCancellation(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSalesorder interface{}, mods queries.Applicator) error {
	var slice []*Salesorder
	var object *Salesorder

	if singular {
		var ok bool
		object, ok = maybeSalesorder.(*Salesorder)
		if !ok {
			object = new(Salesorder)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeSalesorder)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeSalesorder))
			}
		}
	} else {
		s, ok := maybeSalesorder.(*[]*Salesorder)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeSalesorder)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeSalesorder))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &salesorderR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &salesorderR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`alpha.salesorder_cancellations`),
		qm.WhereIn(`alpha.salesorder_cancellations.salesorder_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load SalesorderCancellation")
	}

	var resultSlice []*SalesorderCancellation
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice SalesorderCancellation")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for salesorder_cancellations")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for salesorder_cancellations")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.SalesorderCancellation = foreign
		if foreign.R == nil {
			foreign.R = &salesorderCancellationR{}
		}
		foreign.R.Salesorder = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ID == foreign.SalesorderID {
				local.R.SalesorderCancellation = foreign
				if foreign.R == nil {
					foreign.R = &salesorderCancellationR{}
				}
				foreign.R.Salesorder = local
				break
			}
		}
	}

	return nil
}

// LoadDeliveries allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (salesorderL) LoadDeliveries(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSalesorder interface{}, mods queries.Applicator) error {
	var slice []*Salesorder
	var object *Salesorder

	if singular {
		var ok bool
		object, ok = maybeSalesorder.(*Salesorder)
		if !ok {
			object = new(Salesorder)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeSalesorder)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeSalesorder))
			}
		}
	} else {
		s, ok := maybeSalesorder.(*[]*Salesorder)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeSalesorder)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeSalesorder))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &salesorderR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &salesorderR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`alpha.delivery`),
		qm.WhereIn(`alpha.delivery.salesorder_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load delivery")
	}

	var resultSlice []*Delivery
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice delivery")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on delivery")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for delivery")
	}

	if singular {
		object.R.Deliveries = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &deliveryR{}
			}
			foreign.R.Salesorder = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.SalesorderID) {
				local.R.Deliveries = append(local.R.Deliveries, foreign)
				if foreign.R == nil {
					foreign.R = &deliveryR{}
				}
				foreign.R.Salesorder = local
				break
			}
		}
	}

	return nil
}

// LoadDeliveryComplaints allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (salesorderL) LoadDeliveryComplaints(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSalesorder interface{}, mods queries.Applicator) error {
	var slice []*Salesorder
	var object *Salesorder

	if singular {
		var ok bool
		object, ok = maybeSalesorder.(*Salesorder)
		if !ok {
			object = new(Salesorder)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeSalesorder)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeSalesorder))
			}
		}
	} else {
		s, ok := maybeSalesorder.(*[]*Salesorder)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeSalesorder)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeSalesorder))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &salesorderR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &salesorderR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`alpha.delivery_complaints`),
		qm.WhereIn(`alpha.delivery_complaints.salesorder_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load delivery_complaints")
	}

	var resultSlice []*DeliveryComplaint
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice delivery_complaints")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on delivery_complaints")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for delivery_complaints")
	}

	if singular {
		object.R.DeliveryComplaints = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &deliveryComplaintR{}
			}
			foreign.R.Salesorder = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.SalesorderID) {
				local.R.DeliveryComplaints = append(local.R.DeliveryComplaints, foreign)
				if foreign.R == nil {
					foreign.R = &deliveryComplaintR{}
				}
				foreign.R.Salesorder = local
				break
			}
		}
	}

	return nil
}

// LoadReceipts allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (salesorderL) LoadReceipts(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSalesorder interface{}, mods queries.Applicator) error {
	var slice []*Salesorder
	var object *Salesorder

	if singular {
		var ok bool
		object, ok = maybeSalesorder.(*Salesorder)
		if !ok {
			object = new(Salesorder)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeSalesorder)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeSalesorder))
			}
		}
	} else {
		s, ok := maybeSalesorder.(*[]*Salesorder)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeSalesorder)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeSalesorder))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &salesorderR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &salesorderR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`alpha.receipts`),
		qm.WhereIn(`alpha.receipts.salesorder_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load receipts")
	}

	var resultSlice []*Receipt
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice receipts")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on receipts")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for receipts")
	}

	if singular {
		object.R.Receipts = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &receiptR{}
			}
			foreign.R.Salesorder = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.SalesorderID) {
				local.R.Receipts = append(local.R.Receipts, foreign)
				if foreign.R == nil {
					foreign.R = &receiptR{}
				}
				foreign.R.Salesorder = local
				break
			}
		}
	}

	return nil
}

// LoadRefunds allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (salesorderL) LoadRefunds(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSalesorder interface{}, mods queries.Applicator) error {
	var slice []*Salesorder
	var object *Salesorder

	if singular {
		var ok bool
		object, ok = maybeSalesorder.(*Salesorder)
		if !ok {
			object = new(Salesorder)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeSalesorder)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeSalesorder))
			}
		}
	} else {
		s, ok := maybeSalesorder.(*[]*Salesorder)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeSalesorder)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeSalesorder))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &salesorderR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &salesorderR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`alpha.refunds`),
		qm.WhereIn(`alpha.refunds.salesorder_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load refunds")
	}

	var resultSlice []*Refund
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice refunds")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on refunds")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for refunds")
	}

	if singular {
		object.R.Refunds = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &refundR{}
			}
			foreign.R.Salesorder = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.SalesorderID {
				local.R.Refunds = append(local.R.Refunds, foreign)
				if foreign.R == nil {
					foreign.R = &refundR{}
				}
				foreign.R.Salesorder = local
				break
			}
		}
	}

	return nil
}

// LoadSalesorderItems allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (salesorderL) LoadSalesorderItems(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSalesorder interface{}, mods queries.Applicator) error {
	var slice []*Salesorder
	var object *Salesorder

	if singular {
		var ok bool
		object, ok = maybeSalesorder.(*Salesorder)
		if !ok {
			object = new(Salesorder)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeSalesorder)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeSalesorder))
			}
		}
	} else {
		s, ok := maybeSalesorder.(*[]*Salesorder)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeSalesorder)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeSalesorder))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &salesorderR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &salesorderR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`alpha.salesorder_items`),
		qm.WhereIn(`alpha.salesorder_items.salesorder_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load salesorder_items")
	}

	var resultSlice []*SalesorderItem
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice salesorder_items")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on salesorder_items")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for salesorder_items")
	}

	if singular {
		object.R.SalesorderItems = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &salesorderItemR{}
			}
			foreign.R.Salesorder = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.SalesorderID) {
				local.R.SalesorderItems = append(local.R.SalesorderItems, foreign)
				if foreign.R == nil {
					foreign.R = &salesorderItemR{}
				}
				foreign.R.Salesorder = local
				break
			}
		}
	}

	return nil
}

// LoadTaxExemptions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (salesorderL) LoadTaxExemptions(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSalesorder interface{}, mods queries.Applicator) error {
	var slice []*Salesorder
	var object *Salesorder

	if singular {
		var ok bool
		object, ok = maybeSalesorder.(*Salesorder)
		if !ok {
			object = new(Salesorder)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeSalesorder)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeSalesorder))
			}
		}
	} else {
		s, ok := maybeSalesorder.(*[]*Salesorder)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeSalesorder)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeSalesorder))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &salesorderR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &salesorderR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`alpha.tax_exemptions`),
		qm.WhereIn(`alpha.tax_exemptions.salesorder_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load tax_exemptions")
	}

	var resultSlice []*TaxExemption
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice tax_exemptions")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on tax_exemptions")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for tax_exemptions")
	}

	if singular {
		object.R.TaxExemptions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &taxExemptionR{}
			}
			foreign.R.Salesorder = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.SalesorderID) {
				local.R.TaxExemptions = append(local.R.TaxExemptions, foreign)
				if foreign.R == nil {
					foreign.R = &taxExemptionR{}
				}
				foreign.R.Salesorder = local
				break
			}
		}
	}

	return nil
}

// SetAccountG of the salesorder to the related item.
// Sets o.R.Account to related.
// Adds o to related.R.AccountSalesorders.
// Uses the global database handle.
func (o *Salesorder) SetAccountG(ctx context.Context, insert bool, related *Payment) error {
	return o.SetAccount(ctx, boil.GetContextDB(), insert, related)
}

// SetAccount of the salesorder to the related item.
// Sets o.R.Account to related.
// Adds o to related.R.AccountSalesorders.
func (o *Salesorder) SetAccount(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Payment) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"alpha\".\"salesorders\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
		strmangle.WhereClause("\"", "\"", 2, salesorderPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.AccountID, related.ID)
	if o.R == nil {
		o.R = &salesorderR{
			Account: related,
		}
	} else {
		o.R.Account = related
	}

	if related.R == nil {
		related.R = &paymentR{
			AccountSalesorders: SalesorderSlice{o},
		}
	} else {
		related.R.AccountSalesorders = append(related.R.AccountSalesorders, o)
	}

	return nil
}

// RemoveAccountG relationship.
// Sets o.R.Account to nil.
// Removes o from all passed in related items' relationships struct.
// Uses the global database handle.
func (o *Salesorder) RemoveAccountG(ctx context.Context, related *Payment) error {
	return o.RemoveAccount(ctx, boil.GetContextDB(), related)
}

// RemoveAccount relationship.
// Sets o.R.Account to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Salesorder) RemoveAccount(ctx context.Context, exec boil.ContextExecutor, related *Payment) error {
	var err error

	queries.SetScanner(&o.AccountID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("account_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Account = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.AccountSalesorders {
		if queries.Equal(o.AccountID, ri.AccountID) {
			continue
		}

		ln := len(related.R.AccountSalesorders)
		if ln > 1 && i < ln-1 {
			related.R.AccountSalesorders[i] = related.R.AccountSalesorders[ln-1]
		}
		related.R.AccountSalesorders = related.R.AccountSalesorders[:ln-1]
		break
	}
	return nil
}

// SetAgentG of the salesorder to the related item.
// Sets o.R.Agent to related.
// Adds o to related.R.AgentSalesorders.
// Uses the global database handle.
func (o *Salesorder) SetAgentG(ctx context.Context, insert bool, related *Person) error {
	return o.SetAgent(ctx, boil.GetContextDB(), insert, related)
}

// SetAgent of the salesorder to the related item.
// Sets o.R.Agent to related.
// Adds o to related.R.AgentSalesorders.
func (o *Salesorder) SetAgent(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Person) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"alpha\".\"salesorders\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"agent_id"}),
		strmangle.WhereClause("\"", "\"", 2, salesorderPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.AgentID, related.ID)
	if o.R == nil {
		o.R = &salesorderR{
			Agent: related,
		}
	} else {
		o.R.Agent = related
	}

	if related.R == nil {
		related.R = &personR{
			AgentSalesorders: SalesorderSlice{o},
		}
	} else {
		related.R.AgentSalesorders = append(related.R.AgentSalesorders, o)
	}

	return nil
}

// RemoveAgentG relationship.
// Sets o.R.Agent to nil.
// Removes o from all passed in related items' relationships struct.
// Uses the global database handle.
func (o *Salesorder) RemoveAgentG(ctx context.Context, related *Person) error {
	return o.RemoveAgent(ctx, boil.GetContextDB(), related)
}

// RemoveAgent relationship.
// Sets o.R.Agent to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Salesorder) RemoveAgent(ctx context.Context, exec boil.ContextExecutor, related *Person) error {
	var err error

	queries.SetScanner(&o.AgentID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("agent_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Agent = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.AgentSalesorders {
		if queries.Equal(o.AgentID, ri.AgentID) {
			continue
		}

		ln := len(related.R.AgentSalesorders)
		if ln > 1 && i < ln-1 {
			related.R.AgentSalesorders[i] = related.R.AgentSalesorders[ln-1]
		}
		related.R.AgentSalesorders = related.R.AgentSalesorders[:ln-1]
		break
	}
	return nil
}

// SetBuyerG of the salesorder to the related item.
// Sets o.R.Buyer to related.
// Adds o to related.R.BuyerSalesorders.
// Uses the global database handle.
func (o *Salesorder) SetBuyerG(ctx context.Context, insert bool, related *Company) error {
	return o.SetBuyer(ctx, boil.GetContextDB(), insert, related)
}

// SetBuyer of the salesorder to the related item.
// Sets o.R.Buyer to related.
// Adds o to related.R.BuyerSalesorders.
func (o *Salesorder) SetBuyer(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Company) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"alpha\".\"salesorders\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"buyer_id"}),
		strmangle.WhereClause("\"", "\"", 2, salesorderPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.BuyerID = related.ID
	if o.R == nil {
		o.R = &salesorderR{
			Buyer: related,
		}
	} else {
		o.R.Buyer = related
	}

	if related.R == nil {
		related.R = &companyR{
			BuyerSalesorders: SalesorderSlice{o},
		}
	} else {
		related.R.BuyerSalesorders = append(related.R.BuyerSalesorders, o)
	}

	return nil
}

// SetCommissionG of the salesorder to the related item.
// Sets o.R.Commission to related.
// Adds o to related.R.Salesorders.
// Uses the global database handle.
func (o *Salesorder) SetCommissionG(ctx context.Context, insert bool, related *Commission) error {
	return o.SetCommission(ctx, boil.GetContextDB(), insert, related)
}

// SetCommission of the salesorder to the related item.
// Sets o.R.Commission to related.
// Adds o to related.R.Salesorders.
func (o *Salesorder) SetCommission(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Commission) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"alpha\".\"salesorders\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"commission_id"}),
		strmangle.WhereClause("\"", "\"", 2, salesorderPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.CommissionID = related.ID
	if o.R == nil {
		o.R = &salesorderR{
			Commission: related,
		}
	} else {
		o.R.Commission = related
	}

	if related.R == nil {
		related.R = &commissionR{
			Salesorders: SalesorderSlice{o},
		}
	} else {
		related.R.Salesorders = append(related.R.Salesorders, o)
	}

	return nil
}

// SetSellerG of the salesorder to the related item.
// Sets o.R.Seller to related.
// Adds o to related.R.SellerSalesorders.
// Uses the global database handle.
func (o *Salesorder) SetSellerG(ctx context.Context, insert bool, related *Company) error {
	return o.SetSeller(ctx, boil.GetContextDB(), insert, related)
}

// SetSeller of the salesorder to the related item.
// Sets o.R.Seller to related.
// Adds o to related.R.SellerSalesorders.
func (o *Salesorder) SetSeller(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Company) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"alpha\".\"salesorders\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"seller_id"}),
		strmangle.WhereClause("\"", "\"", 2, salesorderPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.SellerID = related.ID
	if o.R == nil {
		o.R = &salesorderR{
			Seller: related,
		}
	} else {
		o.R.Seller = related
	}

	if related.R == nil {
		related.R = &companyR{
			SellerSalesorders: SalesorderSlice{o},
		}
	} else {
		related.R.SellerSalesorders = append(related.R.SellerSalesorders, o)
	}

	return nil
}

// SetSalesorderCancellationG of the salesorder to the related item.
// Sets o.R.SalesorderCancellation to related.
// Adds o to related.R.Salesorder.
// Uses the global database handle.
func (o *Salesorder) SetSalesorderCancellationG(ctx context.Context, insert bool, related *SalesorderCancellation) error {
	return o.SetSalesorderCancellation(ctx, boil.GetContextDB(), insert, related)
}

// SetSalesorderCancellation of the salesorder to the related item.
// Sets o.R.SalesorderCancellation to related.
// Adds o to related.R.Salesorder.
func (o *Salesorder) SetSalesorderCancellation(ctx context.Context, exec boil.ContextExecutor, insert bool, related *SalesorderCancellation) error {
	var err error

	if insert {
		related.SalesorderID = o.ID

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"alpha\".\"salesorder_cancellations\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, []string{"salesorder_id"}),
			strmangle.WhereClause("\"", "\"", 2, salesorderCancellationPrimaryKeyColumns),
		)
		values := []interface{}{o.ID, related.SalesorderID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.SalesorderID = o.ID
	}

	if o.R == nil {
		o.R = &salesorderR{
			SalesorderCancellation: related,
		}
	} else {
		o.R.SalesorderCancellation = related
	}

	if related.R == nil {
		related.R = &salesorderCancellationR{
			Salesorder: o,
		}
	} else {
		related.R.Salesorder = o
	}
	return nil
}

// AddDeliveriesG adds the given related objects to the existing relationships
// of the salesorder, optionally inserting them as new records.
// Appends related to o.R.Deliveries.
// Sets related.R.Salesorder appropriately.
// Uses the global database handle.
func (o *Salesorder) AddDeliveriesG(ctx context.Context, insert bool, related ...*Delivery) error {
	return o.AddDeliveries(ctx, boil.GetContextDB(), insert, related...)
}

// AddDeliveries adds the given related objects to the existing relationships
// of the salesorder, optionally inserting them as new records.
// Appends related to o.R.Deliveries.
// Sets related.R.Salesorder appropriately.
func (o *Salesorder) AddDeliveries(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Delivery) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.SalesorderID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"alpha\".\"delivery\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"salesorder_id"}),
				strmangle.WhereClause("\"", "\"", 2, deliveryPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.SalesorderID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &salesorderR{
			Deliveries: related,
		}
	} else {
		o.R.Deliveries = append(o.R.Deliveries, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &deliveryR{
				Salesorder: o,
			}
		} else {
			rel.R.Salesorder = o
		}
	}
	return nil
}

// SetDeliveriesG removes all previously related items of the
// salesorder replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Salesorder's Deliveries accordingly.
// Replaces o.R.Deliveries with related.
// Sets related.R.Salesorder's Deliveries accordingly.
// Uses the global database handle.
func (o *Salesorder) SetDeliveriesG(ctx context.Context, insert bool, related ...*Delivery) error {
	return o.SetDeliveries(ctx, boil.GetContextDB(), insert, related...)
}

// SetDeliveries removes all previously related items of the
// salesorder replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Salesorder's Deliveries accordingly.
// Replaces o.R.Deliveries with related.
// Sets related.R.Salesorder's Deliveries accordingly.
func (o *Salesorder) SetDeliveries(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Delivery) error {
	query := "update \"alpha\".\"delivery\" set \"salesorder_id\" = null where \"salesorder_id\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.Deliveries {
			queries.SetScanner(&rel.SalesorderID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Salesorder = nil
		}
		o.R.Deliveries = nil
	}

	return o.AddDeliveries(ctx, exec, insert, related...)
}

// RemoveDeliveriesG relationships from objects passed in.
// Removes related items from R.Deliveries (uses pointer comparison, removal does not keep order)
// Sets related.R.Salesorder.
// Uses the global database handle.
func (o *Salesorder) RemoveDeliveriesG(ctx context.Context, related ...*Delivery) error {
	return o.RemoveDeliveries(ctx, boil.GetContextDB(), related...)
}

// RemoveDeliveries relationships from objects passed in.
// Removes related items from R.Deliveries (uses pointer comparison, removal does not keep order)
// Sets related.R.Salesorder.
func (o *Salesorder) RemoveDeliveries(ctx context.Context, exec boil.ContextExecutor, related ...*Delivery) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.SalesorderID, nil)
		if rel.R != nil {
			rel.R.Salesorder = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("salesorder_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.Deliveries {
			if rel != ri {
				continue
			}

			ln := len(o.R.Deliveries)
			if ln > 1 && i < ln-1 {
				o.R.Deliveries[i] = o.R.Deliveries[ln-1]
			}
			o.R.Deliveries = o.R.Deliveries[:ln-1]
			break
		}
	}

	return nil
}

// AddDeliveryComplaintsG adds the given related objects to the existing relationships
// of the salesorder, optionally inserting them as new records.
// Appends related to o.R.DeliveryComplaints.
// Sets related.R.Salesorder appropriately.
// Uses the global database handle.
func (o *Salesorder) AddDeliveryComplaintsG(ctx context.Context, insert bool, related ...*DeliveryComplaint) error {
	return o.AddDeliveryComplaints(ctx, boil.GetContextDB(), insert, related...)
}

// AddDeliveryComplaints adds the given related objects to the existing relationships
// of the salesorder, optionally inserting them as new records.
// Appends related to o.R.DeliveryComplaints.
// Sets related.R.Salesorder appropriately.
func (o *Salesorder) AddDeliveryComplaints(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DeliveryComplaint) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.SalesorderID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"alpha\".\"delivery_complaints\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"salesorder_id"}),
				strmangle.WhereClause("\"", "\"", 2, deliveryComplaintPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.SalesorderID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &salesorderR{
			DeliveryComplaints: related,
		}
	} else {
		o.R.DeliveryComplaints = append(o.R.DeliveryComplaints, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &deliveryComplaintR{
				Salesorder: o,
			}
		} else {
			rel.R.Salesorder = o
		}
	}
	return nil
}

// SetDeliveryComplaintsG removes all previously related items of the
// salesorder replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Salesorder's DeliveryComplaints accordingly.
// Replaces o.R.DeliveryComplaints with related.
// Sets related.R.Salesorder's DeliveryComplaints accordingly.
// Uses the global database handle.
func (o *Salesorder) SetDeliveryComplaintsG(ctx context.Context, insert bool, related ...*DeliveryComplaint) error {
	return o.SetDeliveryComplaints(ctx, boil.GetContextDB(), insert, related...)
}

// SetDeliveryComplaints removes all previously related items of the
// salesorder replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Salesorder's DeliveryComplaints accordingly.
// Replaces o.R.DeliveryComplaints with related.
// Sets related.R.Salesorder's DeliveryComplaints accordingly.
func (o *Salesorder) SetDeliveryComplaints(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DeliveryComplaint) error {
	query := "update \"alpha\".\"delivery_complaints\" set \"salesorder_id\" = null where \"salesorder_id\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.DeliveryComplaints {
			queries.SetScanner(&rel.SalesorderID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Salesorder = nil
		}
		o.R.DeliveryComplaints = nil
	}

	return o.AddDeliveryComplaints(ctx, exec, insert, related...)
}

// RemoveDeliveryComplaintsG relationships from objects passed in.
// Removes related items from R.DeliveryComplaints (uses pointer comparison, removal does not keep order)
// Sets related.R.Salesorder.
// Uses the global database handle.
func (o *Salesorder) RemoveDeliveryComplaintsG(ctx context.Context, related ...*DeliveryComplaint) error {
	return o.RemoveDeliveryComplaints(ctx, boil.GetContextDB(), related...)
}

// RemoveDeliveryComplaints relationships from objects passed in.
// Removes related items from R.DeliveryComplaints (uses pointer comparison, removal does not keep order)
// Sets related.R.Salesorder.
func (o *Salesorder) RemoveDeliveryComplaints(ctx context.Context, exec boil.ContextExecutor, related ...*DeliveryComplaint) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.SalesorderID, nil)
		if rel.R != nil {
			rel.R.Salesorder = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("salesorder_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.DeliveryComplaints {
			if rel != ri {
				continue
			}

			ln := len(o.R.DeliveryComplaints)
			if ln > 1 && i < ln-1 {
				o.R.DeliveryComplaints[i] = o.R.DeliveryComplaints[ln-1]
			}
			o.R.DeliveryComplaints = o.R.DeliveryComplaints[:ln-1]
			break
		}
	}

	return nil
}

// AddReceiptsG adds the given related objects to the existing relationships
// of the salesorder, optionally inserting them as new records.
// Appends related to o.R.Receipts.
// Sets related.R.Salesorder appropriately.
// Uses the global database handle.
func (o *Salesorder) AddReceiptsG(ctx context.Context, insert bool, related ...*Receipt) error {
	return o.AddReceipts(ctx, boil.GetContextDB(), insert, related...)
}

// AddReceipts adds the given related objects to the existing relationships
// of the salesorder, optionally inserting them as new records.
// Appends related to o.R.Receipts.
// Sets related.R.Salesorder appropriately.
func (o *Salesorder) AddReceipts(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Receipt) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.SalesorderID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"alpha\".\"receipts\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"salesorder_id"}),
				strmangle.WhereClause("\"", "\"", 2, receiptPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.SalesorderID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &salesorderR{
			Receipts: related,
		}
	} else {
		o.R.Receipts = append(o.R.Receipts, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &receiptR{
				Salesorder: o,
			}
		} else {
			rel.R.Salesorder = o
		}
	}
	return nil
}

// SetReceiptsG removes all previously related items of the
// salesorder replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Salesorder's Receipts accordingly.
// Replaces o.R.Receipts with related.
// Sets related.R.Salesorder's Receipts accordingly.
// Uses the global database handle.
func (o *Salesorder) SetReceiptsG(ctx context.Context, insert bool, related ...*Receipt) error {
	return o.SetReceipts(ctx, boil.GetContextDB(), insert, related...)
}

// SetReceipts removes all previously related items of the
// salesorder replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Salesorder's Receipts accordingly.
// Replaces o.R.Receipts with related.
// Sets related.R.Salesorder's Receipts accordingly.
func (o *Salesorder) SetReceipts(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Receipt) error {
	query := "update \"alpha\".\"receipts\" set \"salesorder_id\" = null where \"salesorder_id\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.Receipts {
			queries.SetScanner(&rel.SalesorderID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Salesorder = nil
		}
		o.R.Receipts = nil
	}

	return o.AddReceipts(ctx, exec, insert, related...)
}

// RemoveReceiptsG relationships from objects passed in.
// Removes related items from R.Receipts (uses pointer comparison, removal does not keep order)
// Sets related.R.Salesorder.
// Uses the global database handle.
func (o *Salesorder) RemoveReceiptsG(ctx context.Context, related ...*Receipt) error {
	return o.RemoveReceipts(ctx, boil.GetContextDB(), related...)
}

// RemoveReceipts relationships from objects passed in.
// Removes related items from R.Receipts (uses pointer comparison, removal does not keep order)
// Sets related.R.Salesorder.
func (o *Salesorder) RemoveReceipts(ctx context.Context, exec boil.ContextExecutor, related ...*Receipt) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.SalesorderID, nil)
		if rel.R != nil {
			rel.R.Salesorder = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("salesorder_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.Receipts {
			if rel != ri {
				continue
			}

			ln := len(o.R.Receipts)
			if ln > 1 && i < ln-1 {
				o.R.Receipts[i] = o.R.Receipts[ln-1]
			}
			o.R.Receipts = o.R.Receipts[:ln-1]
			break
		}
	}

	return nil
}

// AddRefundsG adds the given related objects to the existing relationships
// of the salesorder, optionally inserting them as new records.
// Appends related to o.R.Refunds.
// Sets related.R.Salesorder appropriately.
// Uses the global database handle.
func (o *Salesorder) AddRefundsG(ctx context.Context, insert bool, related ...*Refund) error {
	return o.AddRefunds(ctx, boil.GetContextDB(), insert, related...)
}

// AddRefunds adds the given related objects to the existing relationships
// of the salesorder, optionally inserting them as new records.
// Appends related to o.R.Refunds.
// Sets related.R.Salesorder appropriately.
func (o *Salesorder) AddRefunds(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Refund) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.SalesorderID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"alpha\".\"refunds\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"salesorder_id"}),
				strmangle.WhereClause("\"", "\"", 2, refundPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.SalesorderID = o.ID
		}
	}

	if o.R == nil {
		o.R = &salesorderR{
			Refunds: related,
		}
	} else {
		o.R.Refunds = append(o.R.Refunds, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &refundR{
				Salesorder: o,
			}
		} else {
			rel.R.Salesorder = o
		}
	}
	return nil
}

// AddSalesorderItemsG adds the given related objects to the existing relationships
// of the salesorder, optionally inserting them as new records.
// Appends related to o.R.SalesorderItems.
// Sets related.R.Salesorder appropriately.
// Uses the global database handle.
func (o *Salesorder) AddSalesorderItemsG(ctx context.Context, insert bool, related ...*SalesorderItem) error {
	return o.AddSalesorderItems(ctx, boil.GetContextDB(), insert, related...)
}

// AddSalesorderItems adds the given related objects to the existing relationships
// of the salesorder, optionally inserting them as new records.
// Appends related to o.R.SalesorderItems.
// Sets related.R.Salesorder appropriately.
func (o *Salesorder) AddSalesorderItems(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SalesorderItem) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.SalesorderID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"alpha\".\"salesorder_items\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"salesorder_id"}),
				strmangle.WhereClause("\"", "\"", 2, salesorderItemPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.SalesorderID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &salesorderR{
			SalesorderItems: related,
		}
	} else {
		o.R.SalesorderItems = append(o.R.SalesorderItems, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &salesorderItemR{
				Salesorder: o,
			}
		} else {
			rel.R.Salesorder = o
		}
	}
	return nil
}

// SetSalesorderItemsG removes all previously related items of the
// salesorder replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Salesorder's SalesorderItems accordingly.
// Replaces o.R.SalesorderItems with related.
// Sets related.R.Salesorder's SalesorderItems accordingly.
// Uses the global database handle.
func (o *Salesorder) SetSalesorderItemsG(ctx context.Context, insert bool, related ...*SalesorderItem) error {
	return o.SetSalesorderItems(ctx, boil.GetContextDB(), insert, related...)
}

// SetSalesorderItems removes all previously related items of the
// salesorder replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Salesorder's SalesorderItems accordingly.
// Replaces o.R.SalesorderItems with related.
// Sets related.R.Salesorder's SalesorderItems accordingly.
func (o *Salesorder) SetSalesorderItems(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SalesorderItem) error {
	query := "update \"alpha\".\"salesorder_items\" set \"salesorder_id\" = null where \"salesorder_id\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.SalesorderItems {
			queries.SetScanner(&rel.SalesorderID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Salesorder = nil
		}
		o.R.SalesorderItems = nil
	}

	return o.AddSalesorderItems(ctx, exec, insert, related...)
}

// RemoveSalesorderItemsG relationships from objects passed in.
// Removes related items from R.SalesorderItems (uses pointer comparison, removal does not keep order)
// Sets related.R.Salesorder.
// Uses the global database handle.
func (o *Salesorder) RemoveSalesorderItemsG(ctx context.Context, related ...*SalesorderItem) error {
	return o.RemoveSalesorderItems(ctx, boil.GetContextDB(), related...)
}

// RemoveSalesorderItems relationships from objects passed in.
// Removes related items from R.SalesorderItems (uses pointer comparison, removal does not keep order)
// Sets related.R.Salesorder.
func (o *Salesorder) RemoveSalesorderItems(ctx context.Context, exec boil.ContextExecutor, related ...*SalesorderItem) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.SalesorderID, nil)
		if rel.R != nil {
			rel.R.Salesorder = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("salesorder_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.SalesorderItems {
			if rel != ri {
				continue
			}

			ln := len(o.R.SalesorderItems)
			if ln > 1 && i < ln-1 {
				o.R.SalesorderItems[i] = o.R.SalesorderItems[ln-1]
			}
			o.R.SalesorderItems = o.R.SalesorderItems[:ln-1]
			break
		}
	}

	return nil
}

// AddTaxExemptionsG adds the given related objects to the existing relationships
// of the salesorder, optionally inserting them as new records.
// Appends related to o.R.TaxExemptions.
// Sets related.R.Salesorder appropriately.
// Uses the global database handle.
func (o *Salesorder) AddTaxExemptionsG(ctx context.Context, insert bool, related ...*TaxExemption) error {
	return o.AddTaxExemptions(ctx, boil.GetContextDB(), insert, related...)
}

// AddTaxExemptions adds the given related objects to the existing relationships
// of the salesorder, optionally inserting them as new records.
// Appends related to o.R.TaxExemptions.
// Sets related.R.Salesorder appropriately.
func (o *Salesorder) AddTaxExemptions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TaxExemption) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.SalesorderID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"alpha\".\"tax_exemptions\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"salesorder_id"}),
				strmangle.WhereClause("\"", "\"", 2, taxExemptionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.SalesorderID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &salesorderR{
			TaxExemptions: related,
		}
	} else {
		o.R.TaxExemptions = append(o.R.TaxExemptions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &taxExemptionR{
				Salesorder: o,
			}
		} else {
			rel.R.Salesorder = o
		}
	}
	return nil
}

// SetTaxExemptionsG removes all previously related items of the
// salesorder replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Salesorder's TaxExemptions accordingly.
// Replaces o.R.TaxExemptions with related.
// Sets related.R.Salesorder's TaxExemptions accordingly.
// Uses the global database handle.
func (o *Salesorder) SetTaxExemptionsG(ctx context.Context, insert bool, related ...*TaxExemption) error {
	return o.SetTaxExemptions(ctx, boil.GetContextDB(), insert, related...)
}

// SetTaxExemptions removes all previously related items of the
// salesorder replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Salesorder's TaxExemptions accordingly.
// Replaces o.R.TaxExemptions with related.
// Sets related.R.Salesorder's TaxExemptions accordingly.
func (o *Salesorder) SetTaxExemptions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TaxExemption) error {
	query := "update \"alpha\".\"tax_exemptions\" set \"salesorder_id\" = null where \"salesorder_id\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.TaxExemptions {
			queries.SetScanner(&rel.SalesorderID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Salesorder = nil
		}
		o.R.TaxExemptions = nil
	}

	return o.AddTaxExemptions(ctx, exec, insert, related...)
}

// RemoveTaxExemptionsG relationships from objects passed in.
// Removes related items from R.TaxExemptions (uses pointer comparison, removal does not keep order)
// Sets related.R.Salesorder.
// Uses the global database handle.
func (o *Salesorder) RemoveTaxExemptionsG(ctx context.Context, related ...*TaxExemption) error {
	return o.RemoveTaxExemptions(ctx, boil.GetContextDB(), related...)
}

// RemoveTaxExemptions relationships from objects passed in.
// Removes related items from R.TaxExemptions (uses pointer comparison, removal does not keep order)
// Sets related.R.Salesorder.
func (o *Salesorder) RemoveTaxExemptions(ctx context.Context, exec boil.ContextExecutor, related ...*TaxExemption) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.SalesorderID, nil)
		if rel.R != nil {
			rel.R.Salesorder = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("salesorder_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.TaxExemptions {
			if rel != ri {
				continue
			}

			ln := len(o.R.TaxExemptions)
			if ln > 1 && i < ln-1 {
				o.R.TaxExemptions[i] = o.R.TaxExemptions[ln-1]
			}
			o.R.TaxExemptions = o.R.TaxExemptions[:ln-1]
			break
		}
	}

	return nil
}

// Salesorders retrieves all the records using an executor.
func Salesorders(mods ...qm.QueryMod) salesorderQuery {
	mods = append(mods, qm.From("\"alpha\".\"salesorders\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"alpha\".\"salesorders\".*"})
	}

	return salesorderQuery{q}
}

// FindSalesorderG retrieves a single record by ID.
func FindSalesorderG(ctx context.Context, iD int, selectCols ...string) (*Salesorder, error) {
	return FindSalesorder(ctx, boil.GetContextDB(), iD, selectCols...)
}

// FindSalesorder retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindSalesorder(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*Salesorder, error) {
	salesorderObj := &Salesorder{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"alpha\".\"salesorders\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, salesorderObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from salesorders")
	}

	return salesorderObj, nil
}

// InsertG a single record. See Insert for whitelist behavior description.
func (o *Salesorder) InsertG(ctx context.Context, columns boil.Columns) error {
	return o.Insert(ctx, boil.GetContextDB(), columns)
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Salesorder) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no salesorders provided for insertion")
	}

	var err error

	nzDefaults := queries.NonZeroDefaultSet(salesorderColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	salesorderInsertCacheMut.RLock()
	cache, cached := salesorderInsertCache[key]
	salesorderInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			salesorderAllColumns,
			salesorderColumnsWithDefault,
			salesorderColumnsWithoutDefault,
			nzDefaults,
		)
		wl = strmangle.SetComplement(wl, salesorderGeneratedColumns)

		cache.valueMapping, err = queries.BindMapping(salesorderType, salesorderMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(salesorderType, salesorderMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"alpha\".\"salesorders\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"alpha\".\"salesorders\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into salesorders")
	}

	if !cached {
		salesorderInsertCacheMut.Lock()
		salesorderInsertCache[key] = cache
		salesorderInsertCacheMut.Unlock()
	}

	return nil
}

// UpdateG a single Salesorder record using the global executor.
// See Update for more documentation.
func (o *Salesorder) UpdateG(ctx context.Context, columns boil.Columns) (int64, error) {
	return o.Update(ctx, boil.GetContextDB(), columns)
}

// Update uses an executor to update the Salesorder.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Salesorder) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	key := makeCacheKey(columns, nil)
	salesorderUpdateCacheMut.RLock()
	cache, cached := salesorderUpdateCache[key]
	salesorderUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			salesorderAllColumns,
			salesorderPrimaryKeyColumns,
		)
		wl = strmangle.SetComplement(wl, salesorderGeneratedColumns)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update salesorders, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"alpha\".\"salesorders\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, salesorderPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(salesorderType, salesorderMapping, append(wl, salesorderPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update salesorders row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for salesorders")
	}

	if !cached {
		salesorderUpdateCacheMut.Lock()
		salesorderUpdateCache[key] = cache
		salesorderUpdateCacheMut.Unlock()
	}

	return rowsAff, nil
}

// UpdateAllG updates all rows with the specified column values.
func (q salesorderQuery) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return q.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAll updates all rows with the specified column values.
func (q salesorderQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for salesorders")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for salesorders")
	}

	return rowsAff, nil
}

// UpdateAllG updates all rows with the specified column values.
func (o SalesorderSlice) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return o.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o SalesorderSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), salesorderPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"alpha\".\"salesorders\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, salesorderPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in salesorder slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all salesorder")
	}
	return rowsAff, nil
}

// UpsertG attempts an insert, and does an update or ignore on conflict.
func (o *Salesorder) UpsertG(ctx context.Context, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	return o.Upsert(ctx, boil.GetContextDB(), updateOnConflict, conflictColumns, updateColumns, insertColumns)
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Salesorder) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no salesorders provided for upsert")
	}

	nzDefaults := queries.NonZeroDefaultSet(salesorderColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	salesorderUpsertCacheMut.RLock()
	cache, cached := salesorderUpsertCache[key]
	salesorderUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			salesorderAllColumns,
			salesorderColumnsWithDefault,
			salesorderColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			salesorderAllColumns,
			salesorderPrimaryKeyColumns,
		)

		insert = strmangle.SetComplement(insert, salesorderGeneratedColumns)
		update = strmangle.SetComplement(update, salesorderGeneratedColumns)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert salesorders, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(salesorderPrimaryKeyColumns))
			copy(conflict, salesorderPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"alpha\".\"salesorders\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(salesorderType, salesorderMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(salesorderType, salesorderMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert salesorders")
	}

	if !cached {
		salesorderUpsertCacheMut.Lock()
		salesorderUpsertCache[key] = cache
		salesorderUpsertCacheMut.Unlock()
	}

	return nil
}

// DeleteG deletes a single Salesorder record.
// DeleteG will match against the primary key column to find the record to delete.
func (o *Salesorder) DeleteG(ctx context.Context) (int64, error) {
	return o.Delete(ctx, boil.GetContextDB())
}

// Delete deletes a single Salesorder record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Salesorder) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Salesorder provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), salesorderPrimaryKeyMapping)
	sql := "DELETE FROM \"alpha\".\"salesorders\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from salesorders")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for salesorders")
	}

	return rowsAff, nil
}

func (q salesorderQuery) DeleteAllG(ctx context.Context) (int64, error) {
	return q.DeleteAll(ctx, boil.GetContextDB())
}

// DeleteAll deletes all matching rows.
func (q salesorderQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no salesorderQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from salesorders")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for salesorders")
	}

	return rowsAff, nil
}

// DeleteAllG deletes all rows in the slice.
func (o SalesorderSlice) DeleteAllG(ctx context.Context) (int64, error) {
	return o.DeleteAll(ctx, boil.GetContextDB())
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o SalesorderSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), salesorderPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"alpha\".\"salesorders\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, salesorderPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from salesorder slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for salesorders")
	}

	return rowsAff, nil
}

// ReloadG refetches the object from the database using the primary keys.
func (o *Salesorder) ReloadG(ctx context.Context) error {
	if o == nil {
		return errors.New("models: no Salesorder provided for reload")
	}

	return o.Reload(ctx, boil.GetContextDB())
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Salesorder) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindSalesorder(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAllG refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *SalesorderSlice) ReloadAllG(ctx context.Context) error {
	if o == nil {
		return errors.New("models: empty SalesorderSlice provided for reload all")
	}

	return o.ReloadAll(ctx, boil.GetContextDB())
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *SalesorderSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := SalesorderSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), salesorderPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"alpha\".\"salesorders\".* FROM \"alpha\".\"salesorders\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, salesorderPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in SalesorderSlice")
	}

	*o = slice

	return nil
}

// SalesorderExistsG checks if the Salesorder row exists.
func SalesorderExistsG(ctx context.Context, iD int) (bool, error) {
	return SalesorderExists(ctx, boil.GetContextDB(), iD)
}

// SalesorderExists checks if the Salesorder row exists.
func SalesorderExists(ctx context.Context, exec boil.ContextExecutor, iD int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"alpha\".\"salesorders\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if salesorders exists")
	}

	return exists, nil
}
